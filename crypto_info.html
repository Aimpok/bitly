<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Crypto Info</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        /* –°—Ç–∏–ª–∏ –¥–ª—è –≥—Ä–∞—Ñ–∏–∫–∞, –∫–æ—Ç–æ—Ä—ã–µ —Ç—ã —Å–∫–∏–Ω—É–ª */
        .chart-controls { display: flex; gap: 12px; margin-bottom: 10px; align-items: center; padding-left: 4px; }
        .time-btn { font-size: 13px; font-weight: 700; color: #555; padding: 4px 10px; border-radius: 8px; cursor: pointer; transition: 0.2s; background: #111; }
        .time-btn.active { color: #000; background: #FFF; }
        .chart-area { height: 320px; width: 100%; background: transparent; position: relative; overflow: hidden; margin-bottom: 20px; }
        .chart-area canvas { display: block; width: 100%; height: 100%; }
    </style>
</head>
<body>

    <div class="launch-header">
        <div class="top-nav">
            <button class="back-btn" onclick="window.history.back()">
                <svg class="icon" viewBox="0 0 24 24"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>
            </button>
            <div style="font-weight: 700;">Details</div>
            <div style="width: 24px;"></div>
        </div>

        <img id="tokenIcon" src="" class="token-avatar-big" style="display:none;">
        <div id="tokenLetter" class="token-avatar-big" style="display:none; background:#333; display:flex; align-items:center; justify-content:center; font-size:32px; font-weight:700;">?</div>
        
        <div class="token-name-header" id="tokenName">LOADING...</div>

        <div class="stats-split-row">
            <div class="stat-box"><span style="color:#888;">Holders:</span> <span class="stat-val" id="holdersCount">0</span></div>
            <div class="divider-v"></div>
            <div class="stat-box"><span style="color:#888;">Txs:</span> <span class="stat-val" id="txCount">0</span></div>
        </div>

        <div class="market-cap-row">
            <span class="mc-val" id="marketCapVal">0</span>
            <img src="Sprites/Blyx.png" class="mc-icon">
        </div>
        <div style="text-align: center; color: #888; font-size: 13px; margin-bottom: 15px;">
            1 Token = <span id="tokenPriceDisplay" style="color: white; font-weight: 700;">...</span> BLYX
        </div>

        <div class="progress-container" id="bondingContainer">
            <div class="p-bar-bg"><div class="p-bar-fill" id="bondingBar" style="width: 0%;"></div></div>
            <div class="p-labels"><span id="bondingText">0% collected</span><span style="color: #888;">Unlock at 100%</span></div>
        </div>
    </div>

    <div class="tabs-scroll">
        <div class="tab-link active" onclick="switchTab('chart', this)">Chart</div>
        <div class="tab-link" onclick="switchTab('tx', this)">Transactions</div>
        <div class="tab-link" onclick="switchTab('socials', this)">Socials</div>
    </div>

    <div class="content-section">
        <!-- GRAPH CANVAS -->
        <div id="tab-chart">
            <div class="chart-controls">
                <!-- –í –±—É–¥—É—â–µ–º –º–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å –ª–æ–≥–∏–∫—É –¥–ª—è 1h, 1d -->
                <div class="time-btn active" onclick="setFrame(5)">5m</div> 
                <div class="time-btn" onclick="setFrame(15)">15m</div>
                <div class="time-btn" onclick="setFrame(60)">1h</div>
            </div>
            <div class="chart-area">
                <canvas id="chartCanvas"></canvas>
            </div>
            
            <div class="trans-summary">
                <div class="ts-item"><div class="ts-label">Your Balance</div><div class="ts-val" id="myTokenBalance">0</div></div>
                <div class="ts-item" style="text-align: right;"><div class="ts-label">Value (BLYX)</div><div class="ts-val" style="color: var(--accent-green);" id="myTokenValue">‚âà 0</div></div>
            </div>
            <div style="height: 120px;"></div>
        </div>

        <div id="tab-tx" class="hidden">
            <div class="trans-list" id="txList"><div style="text-align:center; padding:20px; color:#555;">Loading...</div></div>
            <div style="height: 120px;"></div>
        </div>

        <div id="tab-socials" class="hidden">
            <div class="social-list"><div class="social-card"><div class="sc-left"><div class="sc-title">Description</div><div class="sc-sub" id="tokenDesc">No description.</div></div></div></div>
            <div style="height: 120px;"></div>
        </div>
    </div>

    <div class="fixed-action-container">
        <div style="display: flex; gap: 10px;">
            <button class="btn-buy-floating" id="sellBtn" style="background: #1c1c1c; color: white; border: 1px solid #333; display:none;" onclick="openTrade('sell')">Sell</button>
            <button class="btn-buy-floating" style="background: white; color: black;" onclick="openTrade('buy')">Buy</button>
        </div>
    </div>

    <div id="tradeOverlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.95); z-index:9999; flex-direction:column; justify-content:center; padding: 20px;">
        <h2 id="tradeTitle" style="text-align:center; margin-bottom:20px; font-size: 24px;">Buy</h2>
        <div class="input-wrapper">
            <input type="number" id="tradeInput" placeholder="Amount" oninput="calcTrade()">
            <div class="input-suffix" id="tradeSuffix">BLYX</div>
        </div>
        <div style="display:flex; justify-content:space-between; margin-bottom:20px; font-size:14px; color:#888;">
            <span>Balance: <span id="tradeBalance" style="color:white;">0</span></span>
            <span id="receiveLabel">You get: <span id="tradeTotal" style="color:white;">0</span> TOKENS</span>
        </div>
        <button class="btn-white-large" onclick="executeTrade()">Confirm</button>
        <button class="btn-text" style="margin-top:10px; width:100%; text-align:center; color:#555;" onclick="closeTrade()">Cancel</button>
    </div>

    <!-- Bottom Nav -->
    <div class="bottom-nav">
        <div class="nav-item" onclick="location.href='index.html'"><svg class="icon" viewBox="0 0 24 24"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline></svg></div>
        <div class="nav-item" onclick="location.href='markets.html'"><svg class="icon" viewBox="0 0 24 24"><line x1="18" y1="20" x2="18" y2="10"></line><line x1="12" y1="20" x2="12" y2="4"></line><line x1="6" y1="20" x2="6" y2="14"></line></svg></div>
        <div class="nav-trade-circle" onclick="location.href='markets.html'"><svg class="icon" style="color:black;" viewBox="0 0 24 24"><polyline points="17 1 21 5 17 9"></polyline><path d="M3 11V9a4 4 0 0 1 4-4h14"></path><polyline points="7 23 3 19 7 15"></polyline><path d="M21 13v2a4 4 0 0 1-4 4H3"></path></svg></div>
        <div class="nav-item" onclick="location.href='transfer.html'"><svg class="icon" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg></div>
        <div class="nav-item" onclick="location.href='wallet.html'"><svg class="icon" viewBox="0 0 24 24"><rect x="1" y="4" width="22" height="16" rx="2" ry="2"></rect><line x1="1" y1="10" x2="23" y2="10"></line></svg></div>
    </div>

    <script type="module">
        import { initUser, subscribeToUser } from './user-service.js';
        import { db } from './firebase-config.js';
        import { doc, onSnapshot, updateDoc, arrayUnion, increment } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        const tg = window.Telegram.WebApp;
        tg.expand();
        tg.setHeaderColor('#000000');

        const tokenId = new URLSearchParams(window.location.search).get('id');
        const TOTAL_SUPPLY = 1000000000;
        
        let currentTokenData = null;
        let currentUserData = null;
        let tradeType = 'buy';
        let currentTimeframe = 5; // minutes

        // Format Helper
        function formatPrice(val) {
            if(!val || val === 0) return "0";
            return val < 0.01 ? val.toFixed(8).replace(/\.?0+$/, "") : val.toFixed(4);
        }

        // --- CHART DRAWING LOGIC ---
        window.setFrame = function(min) {
            currentTimeframe = min;
            // –û–±–Ω–æ–≤–ª—è–µ–º UI –∫–Ω–æ–ø–æ–∫
            document.querySelectorAll('.time-btn').forEach(b => {
                b.classList.remove('active');
                if(b.innerText.includes(min + 'm') || (min===60 && b.innerText==='1h')) b.classList.add('active');
            });
            drawRealChart();
        }

        function generateCandles(transactions, timeframeMinutes) {
            if(!transactions || transactions.length === 0) return [];
            
            const candles = [];
            // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –¥–∞—Ç–µ
            const sorted = [...transactions].sort((a,b) => new Date(a.date) - new Date(b.date));
            const intervalMs = timeframeMinutes * 60 * 1000;

            let currentCandle = null;
            let bucketStart = 0;

            sorted.forEach(tx => {
                const time = new Date(tx.date).getTime();
                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫ –∫–∞–∫–æ–º—É –≤—Ä–µ–º–µ–Ω–Ω–æ–º—É –æ—Ç—Ä–µ–∑–∫—É –æ—Ç–Ω–æ—Å–∏—Ç—Å—è
                const bucket = Math.floor(time / intervalMs) * intervalMs;

                if (!currentCandle || bucket !== bucketStart) {
                    if (currentCandle) candles.push(currentCandle);
                    
                    // Start new candle
                    // Open = prev close OR current price if first
                    const prevClose = candles.length > 0 ? candles[candles.length-1].c : tx.price;
                    
                    bucketStart = bucket;
                    currentCandle = {
                        t: bucket, // time
                        o: prevClose, // open
                        h: tx.price, // high
                        l: tx.price, // low
                        c: tx.price  // close
                    };
                } else {
                    // Update existing candle
                    if (tx.price > currentCandle.h) currentCandle.h = tx.price;
                    if (tx.price < currentCandle.l) currentCandle.l = tx.price;
                    currentCandle.c = tx.price;
                }
            });
            if (currentCandle) candles.push(currentCandle);

            // –ï—Å–ª–∏ –º–∞–ª–æ —Å–≤–µ—á–µ–π, –ø—Ä–æ–¥—É–±–ª–∏—Ä—É–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é –¥–ª—è –≤–∏–∑—É–∞–ª–∞
            if(candles.length < 2 && candles.length > 0) {
                 // –ø—Ä–æ—Å—Ç–æ –∑–∞–≥–ª—É—à–∫–∞, —á—Ç–æ–±—ã –≥—Ä–∞—Ñ–∏–∫ –Ω–µ –±—ã–ª –ø—É—Å—Ç—ã–º
            }
            return candles;
        }

        function drawRealChart() {
            const canvas = document.getElementById('chartCanvas');
            if(!canvas || !currentTokenData) return;
            const parent = canvas.parentElement;
            canvas.width = parent.offsetWidth;
            canvas.height = parent.offsetHeight;
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            const paddingRight = 50; 
            const paddingBottom = 20; 
            const chartW = w - paddingRight;
            const chartH = h - paddingBottom;

            ctx.clearRect(0,0,w,h);

            // 1. Prepare Data
            const txs = currentTokenData.transactions || [];
            // –ï—Å–ª–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π –Ω–µ—Ç –∏–ª–∏ –æ–¥–Ω–∞, —Å–æ–∑–¥–∞–¥–∏–º —Ñ–µ–π–∫–æ–≤—É—é, —á—Ç–æ–±—ã –æ—Ç—Ä–∏—Å–æ–≤–∞–ª–æ—Å—å —Ö–æ—Ç—å —á—Ç–æ-—Ç–æ
            if(txs.length === 0) return;

            const candles = generateCandles(txs, currentTimeframe);
            if(candles.length === 0) return;

            // Find Min/Max for Y-Axis scaling
            let minP = Infinity;
            let maxP = -Infinity;
            candles.forEach(c => {
                if(c.l < minP) minP = c.l;
                if(c.h > maxP) maxP = c.h;
            });
            // Add padding to chart vertically
            if(minP === maxP) { minP *= 0.95; maxP *= 1.05; } // –µ—Å–ª–∏ —Ü–µ–Ω–∞ –Ω–µ –º–µ–Ω—è–ª–∞—Å—å
            const range = maxP - minP;
            const paddedMin = minP - (range * 0.1);
            const paddedMax = maxP + (range * 0.1);
            const scaleY = chartH / (paddedMax - paddedMin);

            // 2. Draw Grid & Prices (Right)
            const steps = 5;
            ctx.font = "600 10px Inter, sans-serif";
            ctx.textAlign = "left";
            ctx.lineWidth = 1;

            for(let i=0; i<=steps; i++) {
                const val = paddedMax - (i * ((paddedMax - paddedMin)/steps));
                const yPos = (i * (chartH/steps));
                // Grid line
                ctx.strokeStyle = '#222';
                ctx.beginPath(); ctx.moveTo(0, yPos); ctx.lineTo(chartW, yPos); ctx.stroke();
                // Price Label
                ctx.fillStyle = '#666';
                ctx.fillText(formatPrice(val), chartW + 5, yPos + 3);
            }

            // 3. Draw Time Grid (Bottom) -- Simplified
            ctx.strokeStyle = '#222';
            const timeSteps = 5;
            const stepW = chartW / timeSteps;
            for(let i=0; i<=timeSteps; i++) {
                const x = i * stepW;
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, chartH); ctx.stroke();
            }

            // 4. Draw Candles
            // Width calc
            // –ß—Ç–æ–±—ã –≥—Ä–∞—Ñ–∏–∫ –≤—Å–µ–≥–¥–∞ –±—ã–ª —Å–ø—Ä–∞–≤–∞, –µ—Å–ª–∏ —Å–≤–µ—á–µ–π –º–∞–ª–æ
            const candleW = 8;
            const gap = 4;
            const totalCandleW = candleW + gap;
            
            // –ù–∞—á–∏–Ω–∞–µ–º —Ä–∏—Å–æ–≤–∞—Ç—å —Å–ø—Ä–∞–≤–∞ –Ω–∞–ª–µ–≤–æ –∏–ª–∏ —Å–ª–µ–≤–∞ –Ω–∞–ø—Ä–∞–≤–æ?
            // –û–±—ã—á–Ω–æ —Å–ª–µ–≤–∞. –ï—Å–ª–∏ —Å–≤–µ—á–µ–π –º–∞–ª–æ, –æ–Ω–∏ –±—É–¥—É—Ç —Å–ª–µ–≤–∞.
            // –ù–æ –≤ —Ç—Ä–µ–π–¥–∏–Ω–≥–µ —Å–≤–µ–∂–∏–µ —Å–ø—Ä–∞–≤–∞.
            // –î–∞–≤–∞–π —Ä–∏—Å–æ–≤–∞—Ç—å —Å –∫–æ–Ω—Ü–∞ –º–∞—Å—Å–∏–≤–∞ (—Å–≤–µ–∂–∏–µ) —Å–ø—Ä–∞–≤–∞.
            
            // X –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ –¥–ª—è —Å–∞–º–æ–π –ø—Ä–∞–≤–æ–π —Å–≤–µ—á–∏
            let currentX = chartW - totalCandleW; 
            
            // –†–∏—Å—É–µ–º —Å –∫–æ–Ω—Ü–∞ –º–∞—Å—Å–∏–≤–∞ (–ø–æ—Å–ª–µ–¥–Ω–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏)
            for (let i = candles.length - 1; i >= 0; i--) {
                const c = candles[i];
                if (currentX < -10) break; // –£—à–ª–∏ –∑–∞ –ª–µ–≤—ã–π –∫—Ä–∞–π

                const isUp = c.c >= c.o;
                const color = isUp ? '#FFFFFF' : '#000000'; // Fill
                const stroke = '#FFFFFF'; // Border

                // Y coordinates (flip coordinate system because 0 is top)
                const yHigh = chartH - ((c.h - paddedMin) * scaleY);
                const yLow = chartH - ((c.l - paddedMin) * scaleY);
                const yOpen = chartH - ((c.o - paddedMin) * scaleY);
                const yClose = chartH - ((c.c - paddedMin) * scaleY);

                // Body coords
                const bodyTop = Math.min(yOpen, yClose);
                const bodyHeight = Math.max(1, Math.abs(yClose - yOpen)); // at least 1px

                // Wick
                ctx.strokeStyle = stroke;
                ctx.beginPath();
                ctx.moveTo(currentX + candleW/2, yHigh);
                ctx.lineTo(currentX + candleW/2, yLow);
                ctx.stroke();

                // Body
                ctx.fillStyle = color;
                ctx.strokeStyle = stroke;
                ctx.fillRect(currentX, bodyTop, candleW, bodyHeight);
                ctx.strokeRect(currentX, bodyTop, candleW, bodyHeight);

                currentX -= totalCandleW;
            }
        }

        // --- INIT & LOGIC ---

        window.switchTab = function(tabName, el) {
            document.querySelectorAll('.tab-link').forEach(t => t.classList.remove('active'));
            el.classList.add('active');
            ['chart', 'tx', 'socials'].forEach(id => document.getElementById('tab-' + id).classList.add('hidden'));
            document.getElementById('tab-' + tabName).classList.remove('hidden');
            if(tabName === 'chart') setTimeout(drawRealChart, 50);
        }

        async function initPage() {
            if(!tokenId) return;
            await initUser();
            onSnapshot(doc(db, "tokens", tokenId), (docSnap) => {
                if (docSnap.exists()) {
                    currentTokenData = docSnap.data();
                    renderTokenInfo();
                    drawRealChart(); // Draw on update
                }
            });
            subscribeToUser((user) => {
                currentUserData = user;
                renderUserPos();
                renderHistory();
            });
            window.addEventListener('resize', drawRealChart);
        }

        function renderTokenInfo() {
            document.getElementById('tokenName').innerText = currentTokenData.name;
            document.getElementById('tokenDesc').innerText = currentTokenData.description || "No description.";
            document.getElementById('holdersCount').innerText = currentTokenData.holdersCount || 1;
            document.getElementById('txCount').innerText = currentTokenData.txCount || 0;
            
            document.getElementById('marketCapVal').innerText = Math.floor(currentTokenData.marketCap || 0).toLocaleString();
            document.getElementById('tokenPriceDisplay').innerText = formatPrice(currentTokenData.price);

            if(currentTokenData.image) {
                document.getElementById('tokenIcon').src = currentTokenData.image;
                document.getElementById('tokenIcon').style.display = 'block';
                document.getElementById('tokenLetter').style.display = 'none';
            } else {
                document.getElementById('tokenIcon').style.display = 'none';
                document.getElementById('tokenLetter').innerText = tokenId[0];
                document.getElementById('tokenLetter').style.display = 'flex';
            }

            const sold = currentTokenData.sold || 0;
            const progress = Math.min((sold / TOTAL_SUPPLY) * 100, 100);
            document.getElementById('bondingBar').style.width = progress + '%';
            document.getElementById('bondingText').innerText = progress.toFixed(2) + '% collected';

            if(progress >= 100) {
                document.getElementById('bondingContainer').style.display = 'none';
                document.getElementById('sellBtn').style.display = 'block';
            } else {
                document.getElementById('bondingContainer').style.display = 'block';
                document.getElementById('sellBtn').style.display = 'none';
            }
        }

        function renderUserPos() {
            if(!currentUserData || !currentTokenData) return;
            const bal = currentUserData.portfolio?.[tokenId] || 0;
            document.getElementById('myTokenBalance').innerText = Math.floor(bal).toLocaleString();
            document.getElementById('myTokenValue').innerText = "‚âà " + (bal * currentTokenData.price).toFixed(2);
        }

        // Trade Functions
        window.openTrade = function(type) {
            tradeType = type;
            const overlay = document.getElementById('tradeOverlay');
            document.getElementById('tradeTitle').innerText = type === 'buy' ? 'Buy' : 'Sell';
            const suffix = type === 'buy' ? 'BLYX' : currentTokenData.id;
            document.getElementById('tradeSuffix').innerText = suffix;
            document.getElementById('tradeInput').value = '';
            document.getElementById('tradeTotal').innerText = '0';
            
            if(type === 'buy') document.getElementById('tradeBalance').innerText = Math.floor(currentUserData.balance) + " BLYX";
            else {
                const bal = currentUserData.portfolio?.[tokenId] || 0;
                document.getElementById('tradeBalance').innerText = Math.floor(bal) + " " + tokenId;
            }
            overlay.style.display = 'flex';
        }
        window.closeTrade = function() { document.getElementById('tradeOverlay').style.display = 'none'; }

        window.calcTrade = function() {
            const amt = parseFloat(document.getElementById('tradeInput').value) || 0;
            const price = currentTokenData.price;
            if(tradeType === 'buy') {
                const tokens = amt / price;
                document.getElementById('tradeTotal').innerText = Math.floor(tokens).toLocaleString();
                document.getElementById('receiveLabel').innerHTML = "Get: <span style='color:white'>" + Math.floor(tokens).toLocaleString() + "</span> TOKENS";
            } else {
                const blyx = amt * price;
                document.getElementById('tradeTotal').innerText = blyx.toFixed(4);
                document.getElementById('receiveLabel').innerHTML = "Get: <span style='color:white'>" + blyx.toFixed(4) + "</span> BLYX";
            }
        }

        window.executeTrade = async function() {
            const inputVal = parseFloat(document.getElementById('tradeInput').value);
            if(!inputVal || inputVal <= 0) return;
            const currentPrice = currentTokenData.price;
            const userRef = doc(db, "users", currentUserData.id.toString());
            const tokenRef = doc(db, "tokens", tokenId);

            try {
                if(tradeType === 'buy') {
                    if(currentUserData.balance < inputVal) { tg.showAlert("Not enough BLYX"); return; }
                    const tokensToGet = inputVal / currentPrice;
                    const newCap = (currentTokenData.marketCap || 0) + inputVal;
                    const newPrice = newCap / TOTAL_SUPPLY;

                    await updateDoc(userRef, {
                        balance: increment(-inputVal),
                        [`portfolio.${tokenId}`]: increment(tokensToGet),
                        transactions: arrayUnion({ type: 'buy', token: tokenId, amount: tokensToGet, price: currentPrice, date: new Date().toISOString() })
                    });
                    await updateDoc(tokenRef, {
                        marketCap: increment(inputVal),
                        sold: increment(tokensToGet),
                        txCount: increment(1),
                        price: newPrice,
                        // –í–∞–∂–Ω–æ! –ü–∏—à–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –≤ –∏—Å—Ç–æ—Ä–∏—é —Ç–æ–∫–µ–Ω–∞ –¥–ª—è –æ–±—â–µ–≥–æ –≥—Ä–∞—Ñ–∏–∫–∞
                        transactions: arrayUnion({ price: newPrice, date: new Date().toISOString() })
                    });
                    tg.showAlert("Bought!");
                } else {
                    const tokensToSell = inputVal;
                    const blyxToGet = tokensToSell * currentPrice;
                    const currentBal = currentUserData.portfolio?.[tokenId] || 0;
                    if(currentBal < tokensToSell) { tg.showAlert("Not enough tokens"); return; }
                    const newCap = Math.max(0, (currentTokenData.marketCap || 0) - blyxToGet);
                    const newPrice = newCap / TOTAL_SUPPLY;

                    await updateDoc(userRef, {
                        balance: increment(blyxToGet),
                        [`portfolio.${tokenId}`]: increment(-tokensToSell),
                        transactions: arrayUnion({ type: 'sell', token: tokenId, amount: tokensToSell, price: currentPrice, date: new Date().toISOString() })
                    });
                    await updateDoc(tokenRef, {
                        marketCap: increment(-blyxToGet),
                        txCount: increment(1),
                        price: newPrice,
                        // –í–∞–∂–Ω–æ! –ü–∏—à–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –≤ –∏—Å—Ç–æ—Ä–∏—é —Ç–æ–∫–µ–Ω–∞
                        transactions: arrayUnion({ price: newPrice, date: new Date().toISOString() })
                    });
                    tg.showAlert("Sold!");
                }
                closeTrade();
            } catch(e) { console.error(e); tg.showAlert(e.message); }
        }

        function renderHistory() {
            const list = document.getElementById('txList');
            const txs = (currentUserData.transactions || []).filter(t => t.token === tokenId).reverse();
            list.innerHTML = '';
            if(txs.length === 0) { list.innerHTML = '<div style="text-align:center; padding:20px; color:#555;">No transactions</div>'; return; }
            txs.forEach(tx => {
                const isBuy = tx.type === 'buy' || tx.type === 'create_buy';
                const action = isBuy ? 'Buy' : 'Sell';
                const color = isBuy ? 'var(--accent-green)' : 'var(--accent-pink)';
                const icon = isBuy ? 'üî•' : '‚ö°';
                const html = `
                <div class="trans-item">
                    <div class="ti-left"><div class="ti-avatar" style="color:${color};background:#222;">${icon}</div><div class="ti-info"><div class="ti-addr">You</div><div class="ti-action" style="color:${color}">${action}</div></div></div>
                    <div class="ti-right"><div class="ti-amount-row">${(tx.amount * tx.price).toFixed(2)} <img src="Sprites/Blyx.png" class="icon-blyx-right"></div><div class="ti-amount-token">${Math.floor(tx.amount).toLocaleString()} ${tokenId}</div></div>
                </div>`;
                list.innerHTML += html;
            });
        }
        initPage();
    </script>
</body>
</html>
