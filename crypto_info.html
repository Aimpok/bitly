<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Crypto Info</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        /* === LOADER === */
        #globalLoader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #000000; z-index: 99999;
            display: flex; justify-content: center; align-items: center;
            transition: opacity 0.3s ease, visibility 0.3s;
        }
        #globalLoader.loaded { opacity: 0; visibility: hidden; pointer-events: none; }
        .custom-spinner {
            width: 40px; height: 40px; border-radius: 50%;
            border: 4px solid #333; border-top-color: #ffffff;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Chart Canvas Fixes */
        .chart-area {
            background: #0A0A0A; 
            border: 1px solid #222;
            border-radius: 16px;
            touch-action: none; 
            position: relative;
            cursor: crosshair;
        }
        
        /* Скрываем кнопки, если они не нужны (логика осталась, но кнопки переделаны) */
        .time-btn.hidden { display: none !important; }
    </style>
</head>
<body>

<div id="globalLoader"><div class="custom-spinner"></div></div>

<div class="launch-header">
    <div class="top-nav">
        <button class="back-btn" onclick="window.history.back()">
            <svg class="icon" viewBox="0 0 24 24"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>
        </button>
        <div style="font-weight: 700;">Details</div>
        <div style="width: 24px;"></div>
    </div>

    <img id="tokenIcon" src="" class="token-avatar-big" style="display:none;">
    <div id="tokenLetter" class="token-avatar-big" style="display:none; background:#333; display:flex; align-items:center; justify-content:center; font-size:32px; font-weight:700;">?</div>

    <div class="token-name-header" id="tokenName">...</div>

    <div class="stats-split-row">
        <div class="stat-box"><span style="color:#888;">Holders:</span> <span class="stat-val" id="holdersCount">0</span></div>
        <div class="divider-v"></div>
        <div class="stat-box"><span style="color:#888;">Txs:</span> <span class="stat-val" id="txCount">0</span></div>
    </div>

    <div class="market-cap-row">
        <span class="mc-val" id="marketCapVal">0</span>
        <img src="Sprites/Blyx.png" class="mc-icon">
    </div>
    <div style="text-align: center; color: #888; font-size: 13px; margin-bottom: 15px;">
        Price: <span id="tokenPriceDisplay" style="color: white; font-weight: 700;">...</span> BLYX
    </div>

    <div class="progress-container" id="bondingContainer">
        <div class="p-bar-bg"><div class="p-bar-fill" id="bondingBar" style="width: 0%;"></div></div>
        <div class="p-labels"><span id="bondingText">0% collected</span><span style="color: #888;">Unlock at 100%</span></div>
    </div>
</div>

<div class="tabs-scroll">
    <div class="tab-link active" onclick="switchTab('chart', this)">Chart</div>
    <div class="tab-link" onclick="switchTab('tx', this)">Transactions</div>
    <div class="tab-link" onclick="switchTab('socials', this)">Socials</div>
</div>

<div class="content-section">
    <div id="tab-chart">
        <div class="chart-controls" id="timeframeButtons">
            <!-- Кнопки теперь передают КЛЮЧ конфигурации -->
            <div class="time-btn active" onclick="setFrame('5m', this)">5m</div> 
            <div class="time-btn" onclick="setFrame('1h', this)">1h</div>
            <div class="time-btn" onclick="setFrame('1d', this)">1d</div>
            <div class="time-btn" onclick="setFrame('1w', this)">1w</div>
            <div class="time-btn" onclick="setFrame('1y', this)">1y</div>
        </div>
        <div class="chart-area"><canvas id="chartCanvas"></canvas></div>
        <div style="height: 120px;"></div>
    </div>

    <div id="tab-tx" class="hidden">
        <div class="trans-list" id="txList"><div style="text-align:center; padding:20px; color:#555;">Loading...</div></div>
        <div style="height: 120px;"></div>
    </div>

    <div id="tab-socials" class="hidden">
        <div class="social-list"><div class="social-card"><div class="sc-left"><div class="sc-title">Description</div><div class="sc-sub" id="tokenDesc">No description.</div></div></div></div>
        <div style="height: 120px;"></div>
    </div>
</div>

<div class="fixed-action-container">
    <button class="btn-buy-floating" id="mainActionBtn" onclick="handleAction()">
        Loading...
    </button>
</div>

<!-- Bottom Nav -->
<div class="bottom-nav">
    <div class="nav-item" onclick="location.href='index.html'"><svg class="icon" viewBox="0 0 24 24"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline></svg></div>
    <div class="nav-item" onclick="location.href='markets.html'"><svg class="icon" viewBox="0 0 24 24"><line x1="18" y1="20" x2="18" y2="10"></line><line x1="12" y1="20" x2="12" y2="4"></line><line x1="6" y1="20" x2="6" y2="14"></line></svg></div>
    <div class="nav-trade-circle" onclick="location.href='markets.html'"><svg class="icon" style="color:black;" viewBox="0 0 24 24"><polyline points="17 1 21 5 17 9"></polyline><path d="M3 11V9a4 4 0 0 1 4-4h14"></path><polyline points="7 23 3 19 7 15"></polyline><path d="M21 13v2a4 4 0 0 1-4 4H3"></path></svg></div>
    <div class="nav-item" onclick="location.href='transfer.html'"><svg class="icon" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg></div>
    <div class="nav-item" onclick="location.href='wallet.html'"><svg class="icon" viewBox="0 0 24 24"><rect x="1" y="4" width="22" height="16" rx="2" ry="2"></rect><line x1="1" y1="10" x2="23" y2="10"></line></svg></div>
</div>

<script type="module">
    import { initUser, subscribeToUser } from './user-service.js';
    import { db } from './firebase-config.js';
    import { doc, onSnapshot } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    const tg = window.Telegram.WebApp;
    tg.expand();
    tg.setHeaderColor('#000000');
    const loader = document.getElementById('globalLoader');

    const tokenId = new URLSearchParams(window.location.search).get('id');
    const TOTAL_SUPPLY = 1000000000;
    
    let currentTokenData = null;
    let currentUserData = null;
    let isP2P = false;
    
    // КОНФИГУРАЦИЯ ТАЙМФРЕЙМОВ (СТРОГО ПО ТЗ)
    // range: сколько минут ВСЕГО на экране
    // step: сколько минут занимает ОДНА свеча
    const CHART_CONFIG = {
        '5m': { range: 5, step: 1 },        // 5 свечей
        '1h': { range: 60, step: 12 },      // 5 свечей (60/12 = 5)
        '1d': { range: 1440, step: 60 },    // 24 свечи
        '1w': { range: 10080, step: 1440 }, // 7 свечей
        '1y': { range: 525600, step: 43200 }// 12 свечей (примерно месяц)
    };

    let currentConfigKey = '5m';
    let activeCursor = null; 

    // FORMATTERS
    function formatPrice(val) {
        if(!val && val !== 0) return "0";
        if(val < 0.0001) return val.toFixed(8);
        if(val < 1) return val.toFixed(6).replace(/\.?0+$/, "");
        if(val >= 1000000) return (val/1000000).toFixed(2) + "M";
        if(val >= 1000) return (val/1000).toFixed(2) + "K";
        return val.toFixed(2);
    }
    
    function formatCompact(num) {
        if (!num) return "0";
        return Intl.NumberFormat('en-US', { notation: "compact", maximumFractionDigits: 2 }).format(num);
    }

    function formatTimeAxis(timestamp, mode) {
        const d = new Date(timestamp);
        const h = d.getHours().toString().padStart(2,'0');
        const m = d.getMinutes().toString().padStart(2,'0');
        
        // Для коротких - время
        if(mode === '5m' || mode === '1h') return `${h}:${m}`;
        // Для длинных - дата
        const day = d.getDate();
        const mon = d.toLocaleString('en', {month:'short'});
        return `${day} ${mon}`;
    }

    window.switchTab = function(tabName, el) {
        document.querySelectorAll('.tab-link').forEach(t => t.classList.remove('active'));
        el.classList.add('active');
        ['chart', 'tx', 'socials'].forEach(id => document.getElementById('tab-' + id).classList.add('hidden'));
        document.getElementById('tab-' + tabName).classList.remove('hidden');
        if(tabName === 'chart') setTimeout(() => drawRealChart(null), 50);
    }

    async function initPage() {
        if(!tokenId) return;
        await initUser();
        
        onSnapshot(doc(db, "tokens", tokenId), (docSnap) => {
            if (docSnap.exists()) {
                currentTokenData = docSnap.data();
                renderUI();
                updateTimeframeButtons(); 
                drawRealChart(null);
                if(loader) loader.classList.add('loaded');
            }
        });
        
        subscribeToUser((user) => {
            currentUserData = user;
            renderHistory();
        });
        
        window.addEventListener('resize', () => drawRealChart(activeCursor));
        setupChartInteractions();
    }

    function updateTimeframeButtons() {
        if (!currentTokenData || !currentTokenData.createdAt) return;
        const created = new Date(currentTokenData.createdAt).getTime();
        const now = Date.now();
        const ageMs = now - created;
        
        const btns = document.querySelectorAll('.time-btn');
        // Показываем кнопки, если токен существует хотя бы 10% от этого времени (примерно)
        // Чтобы не показывать "1 год" для токена которому 5 минут
        btns.forEach(btn => {
            const key = btn.innerText.toLowerCase(); 
            // Упрощенная логика: показываем всё, или скрываем совсем старые
            // Но чтобы не усложнять, пока оставим все кнопки, 
            // график просто покажет пустоту слева (как на биржах)
            btn.classList.remove('hidden');
        });
    }

    function setupChartInteractions() {
        const canvas = document.getElementById('chartCanvas');
        
        const handleMove = (e) => {
            e.preventDefault(); 
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX; clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX; clientY = e.clientY;
            }
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            activeCursor = { x, y };
            drawRealChart(activeCursor);
        };

        const handleEnd = () => {
            activeCursor = null;
            drawRealChart(null);
        };

        canvas.addEventListener('touchstart', handleMove, {passive: false});
        canvas.addEventListener('touchmove', handleMove, {passive: false});
        canvas.addEventListener('touchend', handleEnd);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseleave', handleEnd);
    }

    function renderUI() {
        document.getElementById('tokenName').innerText = currentTokenData.name;
        document.getElementById('tokenDesc').innerText = currentTokenData.description || "No description.";
        document.getElementById('holdersCount').innerText = formatCompact(currentTokenData.holdersCount || 1);
        document.getElementById('txCount').innerText = formatCompact(currentTokenData.txCount || 0);
        document.getElementById('marketCapVal').innerText = formatCompact(currentTokenData.marketCap || 0);
        document.getElementById('tokenPriceDisplay').innerText = formatPrice(currentTokenData.price);

        if(currentTokenData.image) {
            document.getElementById('tokenIcon').src = currentTokenData.image;
            document.getElementById('tokenIcon').style.display = 'block';
            document.getElementById('tokenLetter').style.display = 'none';
        } else {
            document.getElementById('tokenIcon').style.display = 'none';
            document.getElementById('tokenLetter').innerText = tokenId[0];
            document.getElementById('tokenLetter').style.display = 'flex';
        }

        const sold = currentTokenData.sold || 0;
        const progress = Math.min((sold / TOTAL_SUPPLY) * 100, 100);
        document.getElementById('bondingBar').style.width = progress + '%';
        document.getElementById('bondingText').innerText = progress.toFixed(2) + '% collected';

        const btn = document.getElementById('mainActionBtn');
        btn.style.background = "#FFFFFF";
        btn.style.color = "#000000";

        if(progress >= 99.99) {
            isP2P = true;
            document.getElementById('bondingContainer').style.display = 'none';
            btn.innerText = "Go to P2P Market";
        } else {
            isP2P = false;
            document.getElementById('bondingContainer').style.display = 'block';
            btn.innerText = "Buy"; 
        }
    }

    window.handleAction = function() {
        if(isP2P) {
            location.href = `p2p_market.html?id=${tokenId}`;
        } else {
            location.href = `buy_bonding.html?id=${tokenId}`;
        }
    }

    window.setFrame = function(key, btn) {
        currentConfigKey = key;
        document.querySelectorAll('.time-btn').forEach(b => b.classList.remove('active'));
        if(btn) btn.classList.add('active');
        drawRealChart(null);
    }

    // === НОВАЯ ГЕНЕРАЦИЯ: СТРОГО ПО СЕТКЕ ===
    function generateCandles(transactions) {
        if(!transactions || transactions.length === 0) return [];
        
        const sorted = [...transactions].sort((a,b) => new Date(a.date) - new Date(b.date));
        const cfg = CHART_CONFIG[currentConfigKey];
        
        const intervalMs = cfg.step * 60 * 1000; // Размер одной свечи в мс
        const totalRangeMs = cfg.range * 60 * 1000; // Общее время графика
        
        const now = Date.now();
        // Начало графика ВСЕГДА = Сейчас минус Диапазон
        // Это гарантирует фиксированное число свечей на экране
        const chartStartTime = now - totalRangeMs;
        
        // Время создания токена
        const tokenCreatedTime = new Date(currentTokenData.createdAt).getTime();

        const candles = [];
        let lastClose = sorted[0].price; 
        
        // Найдем цену закрытия перед началом графика (если график в середине истории)
        // Если график начинается раньше создания токена, lastClose будет первой ценой
        sorted.forEach(tx => {
            if(new Date(tx.date).getTime() < chartStartTime) lastClose = tx.price;
        });

        // Идем шагами от chartStartTime до now
        // Округляем старт до шага
        const loopStart = Math.floor(chartStartTime / intervalMs) * intervalMs;
        
        for (let t = loopStart; t < now; t += intervalMs) {
            // Если этот временной слот РАНЬШЕ создания токена - рисуем NULL (пустоту)
            // Иначе рисуем свечу
            
            if (t + intervalMs < tokenCreatedTime) {
                // Время еще не пришло для токена
                candles.push(null); // Пустышка
            } else {
                // Токен уже существует
                const bucketTxs = sorted.filter(tx => {
                    const txTime = new Date(tx.date).getTime();
                    return txTime >= t && txTime < t + intervalMs;
                });

                if (bucketTxs.length > 0) {
                    const prices = bucketTxs.map(tx => tx.price);
                    const open = lastClose;
                    const close = prices[prices.length - 1];
                    const high = Math.max(open, ...prices);
                    const low = Math.min(open, ...prices);
                    candles.push({ t: t, o: open, h: high, l: low, c: close });
                    lastClose = close;
                } else {
                    // Нет сделок, цена не менялась -> Плоская свеча
                    candles.push({ t: t, o: lastClose, h: lastClose, l: lastClose, c: lastClose });
                }
            }
        }
        return candles;
    }

    function drawRealChart(cursor) {
        const canvas = document.getElementById('chartCanvas');
        if(!canvas || !currentTokenData) return;
        
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.parentElement.getBoundingClientRect();
        
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        
        const ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);
        
        const w = rect.width;
        const h = rect.height;
        
        const paddingRight = 70; 
        const paddingBottom = 20; 
        const chartW = w - paddingRight;
        const chartH = h - paddingBottom;

        ctx.clearRect(0,0,w,h);

        const txs = currentTokenData.transactions || [];
        // Если вообще нет транзакций, не рисуем
        if(txs.length === 0) return;

        const candles = generateCandles(txs);
        // Если массив пустой или одни null
        if(candles.length === 0) return;

        // Ищем мин/макс ТОЛЬКО среди существующих свечей (не null)
        let minP = Infinity, maxP = -Infinity;
        let hasData = false;
        candles.forEach(c => { 
            if(c) {
                if(c.l < minP) minP = c.l; 
                if(c.h > maxP) maxP = c.h;
                hasData = true;
            }
        });
        
        if(!hasData) {
            // Если данные еще не начались (весь график в прошлом)
            // Просто берем текущую цену для оси
            minP = txs[0].price; 
            maxP = txs[0].price;
        }

        let range = maxP - minP;
        if(range === 0) range = maxP * 0.01;

        const midPoint = (maxP + minP) / 2;
        const visualRange = range * 4; 
        
        const viewMax = midPoint + (visualRange / 2);
        const viewMin = midPoint - (visualRange / 2);
        
        const scaleY = chartH / (viewMax - viewMin);

        // --- GRID ---
        const steps = 5;
        ctx.font = "600 10px Inter";
        ctx.textAlign = "left";
        ctx.lineWidth = 1;
        ctx.setLineDash([]);

        for(let i=0; i<=steps; i++) {
            const priceVal = viewMax - (i * ((viewMax - viewMin)/steps));
            const y = i * (chartH / steps);
            
            ctx.strokeStyle = '#222';
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(chartW, y); ctx.stroke();
            
            ctx.fillStyle = '#666';
            ctx.fillText(formatPrice(priceVal), chartW + 6, y + 4);
        }

        // --- CANDLE WIDTH ---
        // Ширина рассчитывается исходя из количества слотов (candles.length)
        // Так как это число фиксировано конфигом (напр. 24 для 1d), 
        // свечи всегда будут одинаковой нормальной ширины.
        const candleSpacing = chartW / candles.length;
        const candleBodyW = Math.max(1, candleSpacing - 2); // Отступ 2px между свечами
        
        // Подписи времени: ставим каждые N свечей
        const labelStep = Math.ceil(candles.length / 5);

        candles.forEach((c, i) => {
            const xCenter = i * candleSpacing + (candleSpacing / 2);
            
            // Если свеча NULL (еще не существовал токен), пропускаем отрисовку тела
            // НО рисуем сетку времени, если надо
            if(c) {
                const yH = (viewMax - c.h) * scaleY;
                const yL = (viewMax - c.l) * scaleY;
                const yO = (viewMax - c.o) * scaleY;
                const yC = (viewMax - c.c) * scaleY;

                const isUp = c.c >= c.o;
                
                ctx.strokeStyle = '#FFFFFF';
                ctx.beginPath(); ctx.moveTo(xCenter, yH); ctx.lineTo(xCenter, yL); ctx.stroke();

                const bodyTop = Math.min(yO, yC);
                let bodyHeight = Math.abs(yC - yO);
                if (bodyHeight < 1) bodyHeight = 1; 

                const xLeft = xCenter - candleBodyW / 2;

                if (isUp) {
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(xLeft, bodyTop, candleBodyW, bodyHeight);
                } else {
                    ctx.fillStyle = '#000000';
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 1; 
                    ctx.fillRect(xLeft, bodyTop, candleBodyW, bodyHeight);
                    ctx.strokeRect(xLeft, bodyTop, candleBodyW, bodyHeight);
                }
            }

            // Time Labels
            if(i % labelStep === 0 && c) { // Рисуем метку только если есть данные (можно убрать && c если нужна пустая сетка)
                ctx.strokeStyle = '#222';
                ctx.beginPath(); ctx.moveTo(xCenter, 0); ctx.lineTo(xCenter, chartH); ctx.stroke();
                
                ctx.fillStyle = '#666';
                ctx.textAlign = "center";
                // Используем время интервала
                // Для 5м берем время начала бакета
                const t = c ? c.t : (Date.now() - (candles.length - i)*60000); 
                ctx.fillText(formatTimeAxis(t, currentConfigKey), xCenter, h - 5);
            }
        });

        // --- CROSSHAIR ---
        if(cursor && cursor.x < chartW && cursor.y < chartH) {
            ctx.setLineDash([4, 4]);
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#FFFFFF';

            ctx.beginPath(); ctx.moveTo(cursor.x, 0); ctx.lineTo(cursor.x, chartH); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, cursor.y); ctx.lineTo(chartW, cursor.y); ctx.stroke();

            ctx.setLineDash([]);

            const priceAtCursor = viewMax - (cursor.y / scaleY);
            const labelText = formatPrice(priceAtCursor);
            const textWidth = ctx.measureText(labelText).width + 12;
            const labelH = 20;
            
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(chartW, cursor.y - labelH/2, textWidth, labelH);
            
            ctx.fillStyle = '#000000';
            ctx.font = "bold 11px Inter";
            ctx.textAlign = "left";
            ctx.fillText(labelText, chartW + 4, cursor.y + 4);
        }
    }

    function renderHistory() {
        const list = document.getElementById('txList');
        const txs = (currentUserData.transactions || []).filter(t => t.token === tokenId).reverse();
        list.innerHTML = '';
        if(txs.length === 0) { list.innerHTML = '<div style="text-align:center; padding:20px; color:#555;">No transactions</div>'; return; }
        txs.forEach(tx => {
            const isBuy = tx.type.includes('buy');
            const action = isBuy ? 'Buy' : 'Sell';
            const color = isBuy ? '#CCFF00' : '#FF3B30';
            const html = `
            <div class="trans-item">
                <div class="ti-left"><div class="ti-avatar" style="color:${color};background:#222;">${isBuy?'B':'S'}</div>
                <div class="ti-info"><div class="ti-addr">You</div><div class="ti-action" style="color:${color}">${action}</div></div></div>
                <div class="ti-right"><div class="ti-amount-row">${(tx.amount).toFixed(2)} ${tokenId}</div></div>
            </div>`;
            list.innerHTML += html;
        });
    }

    initPage();
</script>
</body>
</html>
