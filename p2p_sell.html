<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sell P2P</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        /* === LOADER STYLES === */
        #globalLoader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #000000; z-index: 99999;
            display: flex; justify-content: center; align-items: center;
            transition: opacity 0.3s ease, visibility 0.3s;
        }
        #globalLoader.loaded { opacity: 0; visibility: hidden; pointer-events: none; }
        .custom-spinner {
            width: 40px; height: 40px; border-radius: 50%;
            border: 4px solid #333; border-top-color: #ffffff;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* КНОПКА УДАЛЕНИЯ (ИКОНКА СПРАВА ВВЕРХУ) */
        .delete-icon-btn {
            background: #1c1c1c;
            color: #888;
            border: none;
            width: 40px; height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            margin-left: auto; /* Двигаем вправо */
        }
        .delete-icon-btn:active {
            background: #333;
            color: #fff;
        }
    </style>
</head>
<body>

    <!-- ЗАГРУЗЧИК -->
    <div id="globalLoader"><div class="custom-spinner"></div></div>

    <div class="header-nav">
        <button class="back-btn" onclick="window.history.back()"><svg class="icon" viewBox="0 0 24 24"><path d="M19 12H5M12 19l-7-7 7-7"/></svg></button>
        <div class="header-title" id="pageTitle">Create Order</div>
        <!-- Кнопка удаления появится здесь -->
        <button class="delete-icon-btn" id="deleteBtn" style="display:none;" onclick="handleDelete()">
            <svg class="icon" viewBox="0 0 24 24"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
        </button>
    </div>

    <div style="padding: 0 16px;">
        <label class="launch-label">Price per 1 token (BLYX)</label>
        <div class="input-wrapper"><input type="text" inputmode="decimal" id="priceInput" oninput="handleInput(this)"></div>

        <label class="launch-label">Amount to sell</label>
        <div class="input-wrapper"><input type="text" inputmode="decimal" id="amountInput" oninput="handleInput(this)"></div>
        <div style="font-size:12px; color:#666; text-align:right; margin-bottom:15px;">Available: <span id="availBal">0</span></div>

        <label class="launch-label">Min Limit (BLYX)</label>
        <div class="input-wrapper"><input type="text" inputmode="decimal" id="minInput" value="100" oninput="handleInput(this)"></div>
        <div style="font-size:12px; color:#666; margin-bottom:5px;">Max Limit: <span id="maxLimitText">Auto (All)</span></div>
        <div id="errorText" class="error-text"></div>
    </div>

    <div class="fixed-bottom-bar">
        <!-- У основной кнопки теперь font-weight: 800 как в launch.html -->
        <button class="btn-white-large btn-disabled" id="publishBtn" onclick="handleSubmit()">Publish Order</button>
    </div>

    <script type="module">
        import { initUser } from './user-service.js';
        import { db } from './firebase-config.js';
        import { doc, getDoc, updateDoc, addDoc, deleteDoc, collection, increment, runTransaction, arrayUnion } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        const tg = window.Telegram.WebApp;
        tg.expand();
        tg.setHeaderColor('#000000');
        const loader = document.getElementById('globalLoader');

        const params = new URLSearchParams(window.location.search);
        const orderId = params.get('oid');
        const tokenIdParam = params.get('id');

        let currentUser = null, myBalance = 0, isEditMode = false, currentOrder = null, activeTokenId = '';

        const fmt = (n) => {
            if (!n && n !== 0) return "";
            let [i, d] = n.toString().split(".");
            i = i.replace(/\B(?=(\d{3})+(?!\d))/g, " ");
            return d ? `${i}.${d.substring(0, 6)}` : i;
        };
        const getVal = (id) => parseFloat(document.getElementById(id).value.replace(/\s/g, '')) || 0;

        window.handleInput = (el) => {
            let v = el.value.replace(/[^0-9.]/g, '');
            if ((v.match(/\./g)||[]).length > 1) v = v.replace(/\.$/, '');
            if (!v || v.endsWith('.')) { el.value = v; validateForm(); return; }
            el.value = fmt(v);
            validateForm();
        };

        async function init() {
            try {
                currentUser = await initUser();
                if (orderId) {
                    isEditMode = true;
                    document.getElementById('pageTitle').innerText = "Edit Order";
                    document.getElementById('publishBtn').innerText = "Save Changes";
                    document.getElementById('deleteBtn').style.display = "flex";

                    const oSnap = await getDoc(doc(db, "orders", orderId));
                    if (!oSnap.exists()) { window.history.back(); return; }
                    
                    currentOrder = { id: oSnap.id, ...oSnap.data() };
                    activeTokenId = currentOrder.tokenId;
                    
                    document.getElementById('priceInput').value = fmt(currentOrder.price);
                    document.getElementById('amountInput').value = fmt(currentOrder.amount);
                    document.getElementById('minInput').value = fmt(currentOrder.minLimit);
                    document.getElementById('amountInput').disabled = true;
                    document.getElementById('availBal').innerText = "Locked in order";
                } else if (tokenIdParam) {
                    activeTokenId = tokenIdParam;
                    myBalance = currentUser.portfolio?.[activeTokenId] || 0;
                    document.getElementById('availBal').innerText = fmt(Math.floor(myBalance));
                    try {
                        const t = await getDoc(doc(db, "tokens", activeTokenId));
                        if(t.exists()) document.getElementById('priceInput').value = t.data().price.toFixed(6);
                    } catch(e){}
                } else { window.history.back(); }
                validateForm();
            } catch(e){ console.error(e); }
            if(loader) loader.classList.add('loaded');
        }

        window.validateForm = () => {
            const p = getVal('priceInput'), a = getVal('amountInput'), m = getVal('minInput');
            const total = p * a;
            const err = document.getElementById('errorText');
            const btn = document.getElementById('publishBtn');
            
            document.getElementById('maxLimitText').innerText = total > 0 ? `${fmt(total)} BLYX` : "Auto";
            btn.classList.add('btn-disabled');
            err.innerText = "";

            if (!a || !p) return;
            if (!isEditMode && a > myBalance) return err.innerText = "Insufficient tokens";
            if (total < 100) return err.innerText = "Total value < 100 BLYX";
            if (m < 100) return err.innerText = "Min limit < 100 BLYX";
            if (m > total) return err.innerText = "Min limit > Total value";

            btn.classList.remove('btn-disabled');
        }

        window.handleSubmit = async () => {
            const p = getVal('priceInput'), a = getVal('amountInput'), m = getVal('minInput');
            const max = p * a;
            
            if (loader) loader.classList.remove('loaded');
            
            try {
                if (isEditMode) {
                    await updateDoc(doc(db, "orders", currentOrder.id), { price: p, minLimit: m, maxLimit: max });
                    tg.showAlert("Updated!");
                } else {
                    const userRef = doc(db, "users", currentUser.id.toString());
                    await updateDoc(userRef, { [`portfolio.${activeTokenId}`]: increment(-a) });
                    await addDoc(collection(db, "orders"), {
                        tokenId: activeTokenId, sellerId: currentUser.id.toString(), sellerName: currentUser.username, sellerAvatar: currentUser.photoUrl,
                        price: p, amount: a, minLimit: m, maxLimit: max, createdAt: new Date().toISOString(), sellerRep: currentUser.tradesCount || 0
                    });
                    tg.showAlert("Created!");
                }
                window.history.back();
            } catch (e) {
                if(loader) loader.classList.add('loaded');
                tg.showAlert("Error: " + e.message);
            }
        };

        window.handleDelete = async () => {
            tg.showConfirm("Delete order?", async (ok) => {
                if(ok) {
                    if (loader) loader.classList.remove('loaded');
                    try {
                        await runTransaction(db, async (t) => {
                            const oRef = doc(db, "orders", currentOrder.id);
                            const uRef = doc(db, "users", currentUser.id.toString());
                            const oDoc = await t.get(oRef);
                            if (!oDoc.exists()) throw "Order not found";
                            const data = oDoc.data();
                            t.delete(oRef);
                            t.update(uRef, {
                                [`portfolio.${data.tokenId}`]: increment(data.amount),
                                transactions: arrayUnion({ type: 'cancel_order', token: data.tokenId, amount: data.amount, date: new Date().toISOString() })
                            });
                        });
                        tg.showAlert("Deleted & Refunded");
                        window.history.back();
                    } catch (e) {
                        if(loader) loader.classList.add('loaded');
                        tg.showAlert("Error: " + e.message);
                    }
                }
            });
        };

        init();
    </script>
</body>
</html>
