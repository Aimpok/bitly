<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sell P2P</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        /* === LOADER STYLES === */
        #globalLoader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #000000; z-index: 99999;
            display: flex; justify-content: center; align-items: center;
            transition: opacity 0.3s ease, visibility 0.3s;
        }
        #globalLoader.loaded { opacity: 0; visibility: hidden; pointer-events: none; }
        .custom-spinner {
            width: 40px; height: 40px; border-radius: 50%;
            border: 4px solid #333; border-top-color: #ffffff;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* СТИЛЬ КНОПКИ УДАЛИТЬ */
        .btn-delete-top {
            background: #1c1c1c;
            color: #FF3B30;
            border: none;
            border-radius: 20px;
            padding: 6px 16px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            margin-left: auto;
            transition: background 0.2s;
        }
        .btn-delete-top:active {
            background: #333;
        }
        .error-text {
            color: #FF3B30;
            font-size: 12px;
            margin-top: 10px;
            min-height: 18px;
            font-weight: 500;
        }
    </style>
</head>
<body>

    <div id="globalLoader"><div class="custom-spinner"></div></div>

    <div class="header-nav">
        <button class="back-btn" onclick="window.history.back()"><svg class="icon" viewBox="0 0 24 24"><path d="M19 12H5M12 19l-7-7 7-7"/></svg></button>
        <div class="header-title" id="pageTitle">Create Order</div>
        <button class="btn-delete-top" id="deleteBtn" style="display:none;" onclick="handleDelete()">Delete</button>
    </div>

    <div style="padding: 0 16px;">
        <label class="launch-label">Price per 1 token (BLYX)</label>
        <div class="input-wrapper">
            <input type="text" inputmode="decimal" id="priceInput" placeholder="0.00004" oninput="handleInput(this)">
        </div>

        <label class="launch-label">Amount to sell</label>
        <div class="input-wrapper">
            <input type="text" inputmode="decimal" id="amountInput" placeholder="Amount" oninput="handleInput(this)">
        </div>
        <div style="font-size:12px; color:#666; text-align:right; margin-bottom:15px;">
            Available: <span id="availBal">0</span>
        </div>

        <label class="launch-label">Min Limit (BLYX)</label>
        <div class="input-wrapper">
            <input type="text" inputmode="decimal" id="minInput" value="100" placeholder="Min BLYX" oninput="handleInput(this)">
        </div>
        
        <div style="font-size:12px; color:#666; margin-bottom:5px;">
            Max Limit: <span id="maxLimitText">Auto (All)</span>
        </div>

        <div id="errorText" class="error-text"></div>
    </div>

    <div class="fixed-bottom-bar">
        <button class="btn-white-large btn-disabled" style="font-weight: 800;" id="publishBtn" onclick="handleSubmit()">Publish Order</button>
    </div>

    <script type="module">
        import { initUser } from './user-service.js';
        import { db } from './firebase-config.js';
        import { doc, getDoc, updateDoc, collection, increment, runTransaction, arrayUnion, setDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        const tg = window.Telegram.WebApp;
        tg.expand();
        tg.setHeaderColor('#000000');
        const loader = document.getElementById('globalLoader');

        const params = new URLSearchParams(window.location.search);
        const orderId = params.get('oid'); 
        const tokenIdParam = params.get('id');

        let currentUser = null;
        let myBalance = 0;
        let isEditMode = false;
        let currentOrder = null;
        let activeTokenId = '';

        function formatDisplay(num) {
            if (num === undefined || num === null) return "0";
            let parts = num.toString().split(".");
            parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, " ");
            if (parts[1]) return parts[0] + "." + parts[1].substring(0, 6);
            return parts[0];
        }

        window.handleInput = function(el) {
            let raw = el.value.replace(/[^0-9.]/g, '');
            if ((raw.match(/\./g) || []).length > 1) raw = raw.replace(/\.$/, '');
            if(raw.endsWith('.')) { el.value = raw; validateForm(); return; }
            if(!raw) { el.value = ""; validateForm(); return; }

            const parts = raw.split('.');
            parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, " ");
            if(parts[1] && parts[1].length > 6) parts[1] = parts[1].substring(0,6);

            el.value = parts.join('.');
            validateForm();
        }

        function getRawValue(id) {
            const val = document.getElementById(id).value;
            return parseFloat(val.replace(/\s/g, '')) || 0;
        }

        async function init() {
            try {
                currentUser = await initUser();

                if (orderId) {
                    isEditMode = true;
                    document.getElementById('pageTitle').innerText = "Edit Order";
                    document.getElementById('publishBtn').innerText = "Save Changes";
                    document.getElementById('deleteBtn').style.display = "block";

                    const oSnap = await getDoc(doc(db, "orders", orderId));
                    if (!oSnap.exists()) {
                        tg.showAlert("Order not found");
                        window.history.back();
                        return;
                    }
                    currentOrder = { id: oSnap.id, ...oSnap.data() };
                    activeTokenId = currentOrder.tokenId;

                    document.getElementById('priceInput').value = currentOrder.price;
                    document.getElementById('amountInput').value = currentOrder.amount;
                    document.getElementById('minInput').value = currentOrder.minLimit;
                    
                    document.getElementById('amountInput').disabled = true;
                    document.getElementById('amountInput').style.opacity = "0.5";
                    document.getElementById('availBal').innerText = "Locked in order";

                } else if (tokenIdParam) {
                    isEditMode = false;
                    activeTokenId = tokenIdParam;
                    myBalance = currentUser.portfolio?.[activeTokenId] || 0;
                    document.getElementById('availBal').innerText = formatDisplay(myBalance);
                    
                    const tSnap = await getDoc(doc(db, "tokens", activeTokenId));
                    if(tSnap.exists()) {
                        document.getElementById('priceInput').value = tSnap.data().price;
                    }
                } else {
                    window.history.back();
                    return;
                }
                
                validateForm();
            } catch(e){ console.error(e); }
            if(loader) loader.classList.add('loaded');
        }

        window.validateForm = function() {
            const price = getRawValue('priceInput');
            const amount = getRawValue('amountInput');
            const min = getRawValue('minInput');
            
            const totalValue = price * amount;
            document.getElementById('maxLimitText').innerText = totalValue > 0 ? `${formatDisplay(totalValue)} BLYX` : "Auto";

            const btn = document.getElementById('publishBtn');
            const err = document.getElementById('errorText');
            btn.classList.add('btn-disabled');
            err.innerText = "";

            if(amount <= 0 || price <= 0) return;
            if(!isEditMode && amount > myBalance) { err.innerText = "Not enough tokens on balance"; return; }
            if(totalValue < 100) { err.innerText = `Total value (${formatDisplay(totalValue)}) < 100 BLYX`; return; }
            if(min < 100) { err.innerText = "Minimum limit must be at least 100 BLYX"; return; }
            if(min > totalValue) { err.innerText = `Min limit > total value`; return; }

            btn.classList.remove('btn-disabled');
        }

        window.handleSubmit = async function() {
            if (isEditMode) updateOrder();
            else createOrder();
        }

        async function createOrder() {
            const price = getRawValue('priceInput');
            const amount = getRawValue('amountInput');
            const min = getRawValue('minInput');
            const max = price * amount;

            tg.showConfirm(`Sell ${formatDisplay(amount)} ${activeTokenId}? Tokens will be locked.`, async (ok) => {
                if(!ok) return;
                if(loader) loader.classList.remove('loaded');
                try {
                    await runTransaction(db, async (transaction) => {
                        const userRef = doc(db, "users", currentUser.id.toString());
                        const tokenRef = doc(db, "tokens", activeTokenId);
                        const orderRef = doc(collection(db, "orders"));

                        const uSnap = await transaction.get(userRef);
                        const currentBalance = uSnap.data().portfolio?.[activeTokenId] || 0;

                        if (currentBalance < amount) throw "Insufficient tokens";

                        // --- ЛОГИКА ХОЛДЕРОВ ---
                        // Если после блокировки в ордер баланс становится 0 -> -1 холдер
                        let holderChange = 0;
                        if (Math.abs(currentBalance - amount) < 0.000001) {
                            holderChange = -1;
                        }

                        // 1. Блокируем токены у юзера
                        transaction.update(userRef, {
                            [`portfolio.${activeTokenId}`]: increment(-amount)
                        });

                        // 2. Создаем ордер
                        transaction.set(orderRef, {
                            tokenId: activeTokenId,
                            sellerId: currentUser.id.toString(),
                            sellerName: currentUser.username || "User",
                            sellerAvatar: currentUser.photoUrl || "", 
                            price: price,
                            amount: amount,
                            minLimit: min,
                            maxLimit: max,
                            createdAt: new Date().toISOString(),
                            sellerRep: currentUser.tradesCount || 0
                        });

                        // 3. Обновляем счетчик холдеров в токене
                        transaction.update(tokenRef, {
                            holdersCount: increment(holderChange)
                        });
                    });

                    tg.showAlert("Order created!");
                    window.history.back();
                } catch(e) {
                    if(loader) loader.classList.add('loaded');
                    tg.showAlert("Error: " + e);
                }
            });
        }

        async function updateOrder() {
            const price = getRawValue('priceInput');
            const min = getRawValue('minInput');
            const max = price * currentOrder.amount;

            if(loader) loader.classList.remove('loaded');
            try {
                await updateDoc(doc(db, "orders", orderId), {
                    price: price,
                    minLimit: min,
                    maxLimit: max
                });
                tg.showAlert("Order updated!");
                window.history.back();
            } catch(e) {
                if(loader) loader.classList.add('loaded');
                tg.showAlert("Error: " + e.message);
            }
        }

        window.handleDelete = async function() {
            tg.showConfirm("Delete order and return tokens?", async (ok) => {
                if(!ok) return;
                if(loader) loader.classList.remove('loaded');
                try {
                    await runTransaction(db, async (transaction) => {
                        const oRef = doc(db, "orders", orderId);
                        const uRef = doc(db, "users", currentUser.id.toString());
                        const tRef = doc(db, "tokens", activeTokenId);

                        const oDoc = await transaction.get(oRef);
                        if(!oDoc.exists()) throw "Order not found";
                        
                        const orderData = oDoc.data();
                        const uDoc = await transaction.get(uRef);
                        const currentBalance = uDoc.data().portfolio?.[activeTokenId] || 0;

                        // --- ЛОГИКА ХОЛДЕРОВ ---
                        // Если возвращаем токены на пустой баланс -> +1 холдер
                        let holderChange = 0;
                        if (currentBalance === 0) {
                            holderChange = 1;
                        }

                        // 1. Удаляем ордер
                        transaction.delete(oRef);

                        // 2. Возвращаем токены юзеру
                        transaction.update(uRef, {
                            [`portfolio.${activeTokenId}`]: increment(orderData.amount),
                            transactions: arrayUnion({
                                type: 'cancel_order',
                                token: activeTokenId,
                                amount: orderData.amount,
                                date: new Date().toISOString()
                            })
                        });

                        // 3. Обновляем счетчик холдеров
                        transaction.update(tRef, {
                            holdersCount: increment(holderChange)
                        });
                    });

                    tg.showAlert("Order deleted. Tokens returned.");
                    window.history.back();
                } catch(e) {
                    if(loader) loader.classList.add('loaded');
                    tg.showAlert("Error: " + e);
                }
            });
        }

        init();
    </script>
</body>
</html>
